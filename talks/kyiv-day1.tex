% Created 2019-07-24 Wed 15:09
% Intended LaTeX compiler: pdflatex
\documentclass[presentation,aspectratio=169,smaller]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{color}
\usepackage[newfloat]{minted}
\usemintedstyle{tango}
\setminted{fontsize=\scriptsize}
\setminted{mathescape=true}
\setbeamertemplate{itemize items}[circle]
\setbeamertemplate{enumerate items}[default]
\setlength{\parskip}{\baselineskip}%
\setlength{\parindent}{0pt}%
\usetheme{default}
\author{Boris Buliga, Valentyn Vakatsiienko}
\date{\today}
\title{Functional Forkshop: Part 1}
\hypersetup{
 pdfauthor={Boris Buliga, Valentyn Vakatsiienko},
 pdftitle={Functional Forkshop: Part 1},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.0.50 (Org mode 9.2.4)}, 
 pdflang={English}}
\begin{document}

\maketitle

\section*{Intro}
\label{sec:orgabea23a}

\begin{frame}[label={sec:orge189bb9}]{About us}
\begin{block}{Valik}
Server guild manager in Kyiv. Formerly forced people to use functional
programming style in the Domains (Premium) team. Now works on Tagless Infra to
provide you with the best tools for your daily needs. Which are all functional,
of course.

\pause
\end{block}

\begin{block}{Boris}
Developer at Payments by Wix team. Jumps between two extremes - Emacs Lisp and
Haskell. Wants to force people around to use both languages, but can't explain
why.
\end{block}
\end{frame}

\begin{frame}[label={sec:orgb1488a1}]{About the Forkshop}
\begin{itemize}
\item Basic forkshop is split into several parts:
\begin{enumerate}
\item Type classes, Semigroups and Monoids.
\item Functors and Applicative Functors.
\item Monads.
\item Readers.
\item Comonads.
\end{enumerate}
\item Theory and practice. Make sure that you are ready to write the code.
\item Target audience is Scala developers learning FP.
\item Forkshop is duplicated in Haskell.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org38d826f},fragile]{Whys}
 \begin{itemize}
\item Functional programming roams (a bit).
\begin{itemize}
\item More projects are using functional programming techniques and idioms (at
different scale).
\end{itemize}
\item Some people are still confused by all these functional talks (\texttt{OptionT}, type
lambdas etc).
\item Having a common language and understanding of some fundamental stuff is
important.
\end{itemize}
\end{frame}

\section*{Today}
\label{sec:org7823df1}

\begin{frame}[label={sec:org7382581}]{Agenda}
\begin{itemize}
\item Type classes
\item Semigroups
\item Monoids
\item 3 interesting™ tasks
\end{itemize}
\end{frame}

\section*{Type classes}
\label{sec:orge017e8a}

\begin{frame}[label={sec:orgc4d4173}]{Type classes}
\begin{itemize}
\item Problem:
\begin{itemize}
\item Application design
\item Data and logic separation
\end{itemize}
\item Plan:
\begin{itemize}
\item Write a simple application
\item Evolve it
\item Check different approaches
\item Introduce type classes
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgbb07f89}]{Application definition}
\begin{itemize}
\item We are writing a game.
\item With multiple different creatures.
\item Everyone introduces themselves.
\item Introduction consists of animations and text showing in a bubble.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org762b457},fragile]{Meet the hero}
 \begin{minted}[]{scala}
case class Hero(name: String, job: String, level: Int) {
  def introduce(): String = s"Hi! My name is $name. I am $level level $job."
}

object Game extends App {
  val player = Hero("Valik", "Black Mage", 20)

  someRealShitSounds()
  drawBubble(player.introduce())
  someRealShitAnimations()
}

// Hi! My name is Valik. I am 20 level Black Mage.
\end{minted}
\end{frame}

\begin{frame}[label={sec:org737178a},fragile]{Every hero needs a monster}
 \begin{minted}[]{scala}
case class Orc(name: String, level: Int) {
  def introduce(): String =
    s"Lok-tar ogar! Me be $name. Me be strong. Level $level strong!"
}

case class Ooze(level: Int) {
  def introduce(): String = 1.to(level).map(_=>"brlup").mkString("-")
}
\end{minted}
\end{frame}

\begin{frame}[label={sec:org50bb738},fragile]{Game}
 \begin{columns}
\begin{column}[t]{0.46\columnwidth}
\begin{minted}[]{scala}
object Game extends App {
  val player = Hero("Valik", "Black Mage", 20)
  val orc = Orc("Garrosh", 105)
  val ooze = Ooze(2)

  // Introduce player
  someRealShitSounds()
  drawBubble(player.introduce())
  someRealShitAnimations()

  // Introduce orc
  someRealShitSounds()
  drawBubble(orc.introduce())
  someRealShitAnimations()

  // Introduce ooze
  someRealShitSounds()
  drawBubble(ooze.introduce())
  someRealShitAnimations()
}

// Hi! My name is Valik. I am 20 level Black Mage.
// Lok-tar ogar! Me be Garrosh. Me be strong. Level 105 strong!
// brlup-brlup
\end{minted}

\pause
\end{column}

\begin{column}[t]{0.46\columnwidth}
\vspace*{0px}

Issues with this code:

\begin{enumerate}
\item Repetition
\item Noise
\item Refactoring (all these \texttt{introduce} are not related to each other).
\end{enumerate}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:org3756575},fragile]{Be DRY, leap for disaster}
 \begin{columns}
\begin{column}[t]{0.46\columnwidth}
\begin{minted}[]{scala}
object Game extends App {
  val player = Hero("Valik", "Black Mage", 20)
  val orc = Orc("Garrosh", 105)
  val ooze = Ooze(2)

  // Introduce player
  someRealShitSounds()
  drawBubble(player.introduce())
  someRealShitAnimations()

  // Introduce orc
  someRealShitSounds()
  drawBubble(orc.introduce())
  someRealShitAnimations()

  // Introduce ooze
  someRealShitSounds()
  drawBubble(ooze.introduce())
  someRealShitAnimations()
}
\end{minted}

\pause
\end{column}

\begin{column}[t]{0.46\columnwidth}
\begin{minted}[]{scala}
def introduce(phrase: String): Unit = {
  someRealShitSounds()
  drawBubble(phrase)
  someRealShitAnimations()
}
\end{minted}

\pause

\begin{minted}[]{scala}
object Game extends App {
  val player = Hero("Valik", "Black Mage", 20)
  val orc = Orc("Garrosh", 105)
  val ooze = Ooze(2)

  introduce(player.introduce())
  introduce(orc.introduce())
  introduce(ooze.introduce())
}
\end{minted}

\pause

Cool, but can we \texttt{introduce(player)}?
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:orga992ff4},fragile]{Introducing abstractions}
 \begin{columns}
\begin{column}[t]{0.5\columnwidth}
\begin{minted}[]{scala}
//



case class Hero(...) {
  def introduce(): String = s"..."
}

case class Orc(...) {
  def introduce(): String = s"..."
}

case class Ooze(...) {
  def introduce(): String = s"..."
}
\end{minted}

\pause
\end{column}

\begin{column}[t]{0.5\columnwidth}
\begin{minted}[]{scala}
trait Introducible {
  def introduce(): String
}

case class Hero(...) extends Introducible {
  override def introduce(): String = s"..."
}

case class Orc(...) extends Introducible {
  override def introduce(): String = s"..."
}

case class Ooze(...) extends Introducible {
  override def introduce(): String = s"..."
}
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:orgfa64566},fragile]{Game with \texttt{trait}}
 \begin{columns}
\begin{column}[t]{0.5\columnwidth}
\begin{minted}[]{scala}
def introduce(phrase: String): Unit = {
  someRealShitSounds()
  drawBubble(phrase)
  someRealShitAnimations()
}

object Game extends App {
  /* ... */

  introduce(player.introduce())
  introduce(orc.introduce())
  introduce(ooze.introduce())
}
\end{minted}

\pause
\end{column}

\begin{column}[t]{0.5\columnwidth}
\begin{minted}[]{scala}
def introduce(creature: Introducible): Unit = {
  someRealShitSounds()
  drawBubble(creature.introduce())
  someRealShitAnimations()
}

object Game extends App {
  /* ... */

  introduce(player)
  introduce(orc)
  introduce(ooze)
}
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:org8a4b3c6},fragile]{Game with trait}
 \begin{itemize}
\item No more \texttt{introduce(\_.introduce())}.
\item We are adaptive. Less code needs to be changed if we need something new in the
\texttt{introduce} function (e.g. sound name) - just add new 'method' to the trait.
\item Refactoring becomes easier.
\end{itemize}

\begin{columns}
\begin{column}[t]{0.5\columnwidth}
\begin{minted}[]{scala}
def introduce(phrase: String): Unit = {
  someRealShitSounds()
  drawBubble(phrase)
  someRealShitAnimations()
}

object Game extends App {
  /* ... */

  introduce(player.introduce())
  introduce(orc.introduce())
  introduce(ooze.introduce())
}
\end{minted}
\end{column}

\begin{column}[t]{0.5\columnwidth}
\begin{minted}[]{scala}
def introduce(creature: Introducible): Unit = {
  someRealShitSounds()
  drawBubble(creature.introduce())
  someRealShitAnimations()
}

object Game extends App {
  /* ... */

  introduce(player)
  introduce(orc)
  introduce(ooze)
}
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:org39ba47d},fragile]{Here comes the cockatrice}
 \begin{minted}[]{scala}
import io.proprietary.monsters.cockatrice._

/* ... */

object Game extends App {
  /* ... */

  val cockatrice = Cockatrice(level = 666, element = Element.Fire)

  introduce(cockatrice) // ???
                        // ain't gonna work
}
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgf4e2030},fragile]{Shawarma to the rescue}
 \begin{columns}
\begin{column}{0.25\columnwidth}
\begin{center}
\includegraphics[height=7cm]{images/shawarma.jpg}
\end{center}
\end{column}

\begin{column}{0.75\columnwidth}
\begin{minted}[]{scala}
import io.proprietary.monsters.cockatrice._

/* ... */

case class CockatriceWrapper(cockatrice: Cockatrice) extends Introducible {
  override def introduce(): String = {
    import cockatrice._
    s"Haha. I am a ${element.shortName} cockatrice of level ${level}."
  }
}

object Game extends App {
  /* ... */

  val cockatrice = Cockatrice(level = 666, element = Element.Fire)
  val cockatriceW = CockatriceWrapper(cockatrice)

  introduce(cockatriceW)

  /* ... */
}


// Haha. I am a fire cockatrice of level 666.
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:orgdf474b7}]{Calm down and reevaluate our goal}
\begin{itemize}
\item Abstraction - caring about what you can do and not what you are. E.g.
separation of data and behaviour.
\end{itemize}
\pause
\begin{itemize}
\item Composition - having a way to express something that can do several things at
once.
\end{itemize}
\pause
\begin{itemize}
\item Extensibility - extending all kind of types:
\begin{itemize}
\item types we own
\item types we don't own
\item even built-in types
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org844c38f},fragile]{\texttt{trait} + wrapper: abstraction}
 Abstraction holds. Proof is the \texttt{introduce} function itself.

\begin{minted}[]{scala}
def introduce(creature: Introducible): Unit = {
  someRealShitSounds()
  drawBubble(creature.introduce())
  someRealShitAnimations()
}
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgd5221ae},fragile]{\texttt{trait} + wrapper: composition}
 Composition holds thanks to \texttt{with} keyword.

\pause

\begin{minted}[]{scala}
trait CanAttack {
  def attack(): Unit
}

def patheticAttack[A <: Introducible with CanAttack](creature: A): Unit
\end{minted}

\pause

\texttt{with} keyword is not commutative

\texttt{Introducible with CanAttack} != \texttt{CanAttack with Introducible}.
\end{frame}

\begin{frame}[label={sec:org2ee94eb},fragile]{\texttt{trait} + wrapper: extensibility}
 Extensibility holds, but with several caveats:

\begin{enumerate}
\item No consistency - we wrap only types we don't own.
\item Wrappers don't compose very well. You might even wrap your wrappers.
\item Bad usability - you can’t interchangeably use wrapper and the underlying
value.
\end{enumerate}
\end{frame}

\begin{frame}[label={sec:org8445418}]{You know where it’s going to, right?}
\pause

\begin{center}
\includegraphics[height=7cm]{images/f_.jpg}
\end{center}
\end{frame}

\begin{frame}[label={sec:orge072b0e},fragile]{Dividing data and behaviour}
 \begin{columns}
\begin{column}[t]{0.5\columnwidth}
\begin{minted}[]{scala}
trait Introducible {
  def introduce(): String
}

def introduce(creatute: Introducible): Unit = {

  /* ... */
  drawBubble(creatute.introduce())
  /* ... */
}
\end{minted}

\pause
\end{column}

\begin{column}[t]{0.5\columnwidth}
\begin{minted}[]{scala}
trait Introducible[A] {
  def introduce(a: A): String
}

def introduce[A](creature: A,
                 impl: Introducible[A]): Unit = {
  /* ... */
  drawBubble(impl.introduce(creature))
  /* ... */
}
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:orgca5309d},fragile]{Usage}
 \begin{minted}[]{scala}
// Define new trait
trait Introducible[A] {
  def introduce(a: A): String
}
\end{minted}

\pause

\begin{minted}[]{scala}
// Remove behaviour from data
case class Hero(name: String, job: String, level: Int)
\end{minted}

\pause

\begin{minted}[]{scala}
// Implement behaviour as a value in companion object
object Hero {
  val introducibleHero: Introducible[Hero] = new Introducible[Hero] {
    override def introduce(a: Hero): String =
      s"..."
  }
}
\end{minted}

\pause

\begin{minted}[]{scala}
// Pass data and behaviour separately
object Game extends App {
  /* ... */
  introduce(
    creature = hero,
    impl = Hero.introducibleHero
  )
}
\end{minted}
\end{frame}

\begin{frame}[label={sec:orge7fe8c1},fragile]{External types? Pff\ldots{}}
 \begin{minted}[]{scala}
import io.proprietary.monsters.cockatrice._

// Implement behaviour as a value in companion object
object CockatriceInstances {
  val introducibleCockatrice: Introducible[Cockatrice] = new Introducible[Cockatrice] {
    override def introduce(a: Cockatrice): String =
      s"..."
  }
}
\end{minted}

\pause

\begin{minted}[]{scala}
// Pass data and behaviour separately
object Game extends App {
  /* ... */
  introduce(
    creature = cockatrice,
    impl = CockatriceInstances.introducibleCockatrice
  )
}
\end{minted}
\end{frame}

\begin{frame}[label={sec:org78edbdb}]{But passing implementation around is\ldots{}}
\begin{center}
\includegraphics[height=5cm]{images/cucumber.jpg}
\end{center}

Cucumbersome
\end{frame}

\begin{frame}[label={sec:org0fc38f5},fragile]{So implicits :(}
 \begin{columns}
\begin{column}[t]{0.5\columnwidth}
\begin{minted}[]{scala}
object Hero {
  val introducibleHero:
      Introducible[Hero] = ???
}

object CockatriceInstances {
  val introducibleCockatrice:
      Introducible[Cockatrice] = ???
}

def introduce[A](creature: A,
                 impl: Introducible[A]): Unit = {
  /* ... */
  drawBubble(impl.introduce(creature))
  /* ... */
}

object Game extends App {
  /* ... */
  introduce(hero, introducibleHero)
  introduce(cockatrice, introducibleCockatrice)
}
\end{minted}

\pause
\end{column}

\begin{column}[t]{0.5\columnwidth}
\begin{minted}[]{scala}
object Hero {
  implicit val introducibleHero:
      Introducible[Hero] = ???
}

object CockatriceInstances {
  implicit val introducibleCockatrice:
      Introducible[Cockatrice] = ???
}

def introduce[A](creature: A)
             (implicit impl: Introducible[A]): Unit = {
  /* ... */
  drawBubble(impl.introduce(creature))
  /* ... */
}

object Game extends App {
  /* ... */
  introduce(hero)
  introduce(cockatrice)
}
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:orge2c636d},fragile]{Summoning the summoner}
 \begin{columns}
\begin{column}[t]{0.5\columnwidth}
\begin{minted}[]{scala}
trait Introducible[A] {
  def introduce(a: A): String
}






def introduce[A](creature: A)
             (implicit impl: Introducible[A]): Unit = {
  /* ... */
  drawBubble(impl.introduce(creature))
  /* ... */
}
\end{minted}

\pause
\end{column}

\begin{column}[t]{0.5\columnwidth}
\begin{minted}[]{scala}
trait Introducible[A] {
  def introduce(a: A): String
}

object Introducible {
  def apply[A: Introducible]: Introducible[A] =
    implicitly[Introducible[A]]
}

def introduce[A: Introducible](creature: A): Unit = {

  /* ... */
  drawBubble(Introducible[A].introduce(creature))
  /* ... */
}
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:org7da29a3}]{What have we done?}
\alert{Type class} is just a construct that supports \alert{ad hoc polymorphism}. E.g.
allows one to define polymorphic functions that can be applied to arguments of
different types and behave differently based the type of the arguments.

In other words, \alert{type classes} are solution for supporting \alert{function
overloading}.

\pause

In Scala this can be achieved in several ways:

\begin{itemize}
\item Class inheritance or traits.
\item Type classes (traits + implicits).
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orga980602},fragile]{Type classes: abstraction}
 Abstraction holds. Proof is the \texttt{introduce} function itself.

\pause

\begin{columns}
\begin{column}[t]{0.5\columnwidth}
\begin{minted}[]{scala}
def introduce(creature: Introducible): Unit = {
  /* ... */
  drawBubble(creature.introduce())
  /* ... */
}
\end{minted}
\end{column}

\begin{column}[t]{0.5\columnwidth}
\begin{minted}[]{scala}
def introduce[A: Introducible](creature: A): Unit = {
  /* ... */
  drawBubble(Introducible[A].introduce(creature))
  /* ... */
}
\end{minted}

\pause
\end{column}
\end{columns}

We gain literal data and behaviour separation.
\end{frame}

\begin{frame}[label={sec:org02233da},fragile]{Type classes: composition}
 Composition holds. We just pass two different behaviours.

\pause

\begin{minted}[]{scala}
def patheticAttack[A <: Introducible with CanAttack](creature: A): Unit
\end{minted}

\pause

\begin{minted}[]{scala}
def patheticAttack[A : Introducible : CanAttack](creature: A): Unit
def patheticAttack[A](creature: A)
                  (implicit introducibleImpl: Introducible[A],
                   implicit canAttackImpl: CanAttack[A]): Unit
\end{minted}

\pause

But with type classes we don't care about the order.
\end{frame}

\begin{frame}[label={sec:org65a0583}]{Type classes: extensibility}
Extensibility holds with some gains:

\begin{enumerate}
\item Consistency - we treat our own type the same way we treat external types.
\item Usability - no wrappers, no interchangeability problem.
\end{enumerate}
\end{frame}

\begin{frame}[label={sec:orgd87ed38}]{Type classes: final thoughts}
\begin{enumerate}
\item Simple idea giving us good properties.
\item Found a good use for controversial implicits feature.
\item Literal separation of data and values.
\item Good for overloading.
\item As with any abstraction, not so good for performance.
\end{enumerate}
\end{frame}

\section*{Transition}
\label{sec:org46a9f80}

\begin{frame}[label={sec:org631c8b1}]{Warning}
In the next two parts we are going to talk about:

\begin{enumerate}
\item Abstract mathematical objects.
\item Laws and properties.
\end{enumerate}

\pause

Only after that:

\begin{enumerate}
\item Practical meaning.
\item Tasks.
\end{enumerate}

\pause

Please keep calm and remember that our focus is practical importance :)
\end{frame}

\section*{Semigroup}
\label{sec:org356be9c}

\begin{frame}[label={sec:orge2efe93}]{Semigroup}
Semigroup is a set \(S\) with binary closed operation \(\cdot : S \times S
\rightarrow S\) that satisfies associativity property:

$$\forall a, b, c \in S : (a \cdot b) \cdot c = a \cdot (b \cdot c)$$

Operation is closed when \(\forall a, b \in S : a \cdot b \in S\).
\end{frame}

\begin{frame}[label={sec:org621f3d5},fragile]{But it’s not that scary}
 \begin{columns}
\begin{column}{0.5\columnwidth}
\begin{minted}[]{scala}
package object typeclass {

  //
  // Laws:
  //   1. $\forall a, b, c \in A: (a \cdot b) \cdot c = a \cdot (b \cdot c)$
  //
  trait Semigroup[A] {
    def combine(x: A, y: A): A
  }

  object Semigroup {
    def apply[A: Semigroup]: Semigroup[A] =
      implicitly[Semigroup[A]]
  }

}
\end{minted}

\pause

In simple words, semigroup is a set with means of combining elements of that
set.

\pause
\end{column}

\begin{column}{0.5\columnwidth}
\begin{center}
\includegraphics[height=7cm]{images/scary.png}
\end{center}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:orge174b0e}]{Important!}
Semigroup is a pair of the set and the operation.

You can’t say that string is a semigroup, you must provide an operation.

And in many cases there is more than one operation for a set to form a
semigroup.
\end{frame}

\begin{frame}[label={sec:org7c56c5b},fragile]{What is law?}
 \begin{itemize}
\item In programming world it's just a contract.
\end{itemize}

\pause
\begin{itemize}
\item Operations in the type classes are very generic.
\begin{minted}[]{scala}
def combine(x: A, y: A): A
\end{minted}
\end{itemize}

\pause
\begin{itemize}
\item So type classes should have some associated laws.
\end{itemize}

\pause
\begin{itemize}
\item Laws describe properties of these operations and connection between operations
in one type class.
\end{itemize}

\pause
\begin{itemize}
\item Contract of the interface gives us confidence when we write generic code.
\end{itemize}

\pause
\begin{itemize}
\item And as you will see, we really care about these laws.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org6383d52},fragile]{Instance example}
 \begin{minted}[]{scala}
package object implicits {
  implicit val stringSemigroup: Semigroup[String] = new Semigroup[String] {
    override def combine(x: String, y: String): String = x + y
  }
}
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgcb26bd7},fragile]{Checking laws - \sout{pen and paper} in comments}
 \begin{minted}[]{scala}
package object implicits {
  implicit val stringSemigroup: Semigroup[String] = new Semigroup[String] {
    override def combine(x: String, y: String): String = x + y
  }
}

/*
combine(a, combine(b, c))
  = combine(a, b + c)
  = a + (b + c)
  = (associativity of +)
  = (a + b) + c = combine(a + b, c)
  = combine(combine(a, b), c)
*/
\end{minted}
\end{frame}

\begin{frame}[label={sec:org2b75e9e}]{You're programmer after all}
\begin{center}
\includegraphics[height=7cm]{images/you-re-programmer.jpg}
\end{center}
\end{frame}

\begin{frame}[label={sec:orgbeb5a7b},fragile]{Question on the interview: property based testing}
 \begin{minted}[]{scala}
object SemigroupSpecification extends Properties("Semigroup") with SemigroupSpecificationSupport {
 include(semigroup[String](stringSemigroup))
}

trait SemigroupSpecificationSupport {
 def semigroup[A](sg: Semigroup[A])(implicit ar: Arbitrary[A], tag: ClassTag[A]): Properties =
   new Properties(s"Semigroup[${tag.toString}]") {


     // $\forall a, b, c \in A: (a \cdot b) \cdot c = a \cdot (b \cdot c)$
     property("associativity") = forAll { (a: A, b: A, c: A) =>
       sg.combine(sg.combine(a, b), c) =? sg.combine(a, sg.combine(b, c))
     }


   }
}

/*
+ Semigroup.Semigroup[java.lang.String].associativity: OK, passed 100 tests
  .
*/
\end{minted}
\end{frame}

\begin{frame}[label={sec:org1ccb876},fragile]{More than one valid instance}
 \begin{minted}[]{scala}
package object implicits {
  implicit val stringSemigroup: Semigroup[String] = new Semigroup[String] {
    override def combine(x: String, y: String): String = x
  }
}
\end{minted}
\end{frame}

\begin{frame}[label={sec:org5d37f0e}]{More examples}
\begin{itemize}
\item Numbers with \(+\), \(*\), \(min\), \(max\)
\item Booleans with conjunction, disjunction, implication etc.
\item Square nonnegative matrices with multiplication.
\item Lists, Strings, Maps etc. with concatenation/union
\item We will see even more examples during practical part.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org1808bfe}]{Contra-examples}
\begin{itemize}
\item \(\{\mathbb{N}, /\}\) is not a Semigroup, because \(/\) is not associative.
\item The same goes for \(\{\mathbb{N}, a^b \}\).
\item \(\{\mathbb{N}, -\}\) is not a Semigroup, because \(-\) is not a closed operation,
e.g. \(\exists a, b \in \mathbb{N}: a - b \notin \mathbb{N}\),
for example \(10 - 15 = -5 \notin \mathbb{N}\).
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org777d9eb},fragile]{Lets hack}
 \begin{enumerate}
\item Clone \texttt{git@github.com:d12frosted/wax.git}
\item Import it as \texttt{sbt} project.
\end{enumerate}
\pause
\begin{enumerate}
\item Task 1
\begin{enumerate}
\item Implement missing \texttt{Semigroup} instances in
\texttt{wax.typeclass.semigroup.cats.implicits}
\item Run \texttt{wax.typeclass.semigroup.laws.cats.SemigroupSpec}
\end{enumerate}
\end{enumerate}
\pause
\begin{enumerate}
\item Task 2
\begin{enumerate}
\item Create \texttt{Semigroup} typeclass manually in
\texttt{wax.typeclass.semigroup.manual.typeclass}
\item Implement missing \texttt{Semigroup} instances in
\texttt{wax.typeclass.semigroup.manual.implicits}
\item Run \texttt{wax.typeclass.semigroup.laws.manual.SemigroupSpec}
\end{enumerate}
\end{enumerate}
\end{frame}

\section*{Monoid}
\label{sec:org1731e22}

\begin{frame}[label={sec:org1ca733f}]{Monoid}
A monoid is a set \(S\) with binary closed operation \(\cdot : S \times S
\rightarrow S\) that satisfies associativity property:
$$\forall a, b, c \in S : (a \cdot b) \cdot c = a \cdot (b \cdot c)$$

and identity element \(e\) that satisfies
$$\forall a \in S : e \cdot a = a \cdot e = a$$

Operation is closed when \(\forall a, b \in S : a \cdot b \in S\).

\pause

In other words, monoid is just a semigroup with identity element.
\end{frame}

\begin{frame}[label={sec:orgb873182},fragile]{Again, it's not that scary}
 \begin{minted}[]{scala}
package object typeclass {

  //
  // Laws:
  //   1. $\forall a, b, c \in S : (a \cdot b) \cdot c = a \cdot (b \cdot c)$
  //   2. $\forall a \in S : e \cdot a = a \cdot e = a$
  //
  trait Monoid[A] extends Semigroup[A] {
    def empty: A
  }

  object Monoid {
    def apply[A: Monoid]: Monoid[A] = implicitly[Monoid[A]]
  }

}
\end{minted}
\end{frame}

\begin{frame}[label={sec:org12bb8d4},fragile]{Examples}
 \begin{itemize}
\item \(\{\mathbb{N}_0, +\}\), where \(0\) is the identity element.
\item \(\{\mathbb{N}, *\}\), where \(1\) is the identity element.
\item Boolean with XOR, XNOR, OR, AND.
\item String with concatenation (empty string is identity element).
\end{itemize}

\pause

But not every Semigroup forms a Monoid (we are not talking about free monoids
here):

\begin{itemize}
\item \texttt{BigNumber} practically doesn’t have identity element for \texttt{min}.
\end{itemize}
\end{frame}

\section*{Transition to the practical part}
\label{sec:orgac4d55c}

\begin{frame}[label={sec:org67d4174}]{The most important question}
\pause

\begin{center}
\includegraphics[height=5cm]{images/whyyy.png}
\end{center}

Why did we learn this?
\end{frame}

\section*{Fibonacci}
\label{sec:org954a1d9}

\begin{frame}[label={sec:orgbcac9ce}]{The Fibonacci numbers}
\pause

On the interview we ask people to write a function that returns the nth
Fibonacci number.

\pause

\begin{align*}
  F_0 &= 0 \\
  F_1 &= 1 \\
  F_n &= F_{n - 1} + F_{n - 2}, \forall n > 1 \\
\end{align*}
\end{frame}

\begin{frame}[label={sec:orgdbc30a0},fragile]{Solution}
 \begin{columns}
\begin{column}[t]{0.5\columnwidth}
\begin{block}{What we expect}
\begin{minted}[]{scala}
def fib(n: Int): Int = {
  def fibTail(n: Int, a: Int, b: Int): Int = n match {
    case 0 => a
    case _ => fibTail(n - 1, b, a + b)
  }

  fibTail(n, 0, 1)
}
\end{minted}

\pause
\end{block}
\end{column}

\begin{column}[t]{0.5\columnwidth}
\begin{block}{Ideal solution}
\begin{align*}
  F_n &= \frac {\phi ^ n - {(- \phi)}^{-n}} {\sqrt{5}} \\
  &= \frac {\phi ^ n - {(- \phi)}^{-n}} {2\phi - 1} \\
  \\
  \phi &= \frac {1 + \sqrt{5}}{2}
\end{align*}

\pause
\end{block}
\end{column}
\end{columns}

As they say, truth is somewhere in the logarithm.
\end{frame}

\begin{frame}[label={sec:orgd889625},fragile]{Two folds}
 \begin{itemize}
\item \texttt{def foldl[A, B](xs: Seq[A])(z: B)(op: B => A => B): B}
\begin{itemize}
\item Folds the structure from left to right
\end{itemize}
\end{itemize}

\pause

\begin{center}
\includegraphics[height=5cm]{.dot/foldl-1.png}
\end{center}
\end{frame}

\begin{frame}[label={sec:org959becd},fragile]{Two folds}
 \begin{itemize}
\item \texttt{def foldl[A, B](xs: Seq[A])(z: B)(op: B => A => B): B}
\item \texttt{def foldr[A, B](xs: Seq[A])(z: B)(op: A => B => B): B}
\begin{itemize}
\item Folds the structure from right to left
\end{itemize}
\end{itemize}

\pause

\begin{center}
\includegraphics[height=5cm]{.dot/foldr-1.png}
\end{center}
\end{frame}

\begin{frame}[label={sec:org3a89752},fragile]{Two folds}
 \begin{itemize}
\item \texttt{def foldl[A, B](xs: Seq[A])(z: B)(op: B => A => B): B}
\item \texttt{def foldr[A, B](xs: Seq[A])(z: B)(op: A => B => B): B}
\item Since combining function is asymmetrical in its types:
\begin{itemize}
\item It’s impossible to place parentheses in the arbitrary fashion or even just
change the direction of the \texttt{fold}
\item It’s impossible to implement a total \texttt{fold} without default value of type \texttt{B}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orga52241c}]{Two folds}
\begin{columns}
\begin{column}[t]{0.5\columnwidth}
\begin{block}{foldl}
\begin{center}
\includegraphics[height=6cm]{.dot/foldl-1.png}
\end{center}
\end{block}
\end{column}

\begin{column}[t]{0.5\columnwidth}
\begin{block}{foldr}
\begin{center}
\includegraphics[height=6cm]{.dot/foldr-1.png}
\end{center}
\end{block}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:orga407fd0},fragile]{What Monoid gives us}
 \begin{itemize}
\item Combining function is symmetrical (\texttt{combine : A -> A -> A}).
\end{itemize}
\pause
\begin{itemize}
\item Identity element of type \texttt{A} (\texttt{empty}).
\end{itemize}
\pause
\begin{itemize}
\item So we can define a special \texttt{fold}
\begin{itemize}
\item \texttt{def foldMonoid[A: Monoid](xs: Seq[A]): A}
\end{itemize}
\end{itemize}
\pause
\begin{itemize}
\item Associativity law says that we can put parentheses in an arbitrary fashion.
\end{itemize}
\pause
\begin{itemize}
\item Identity law says that we can place identity element anywhere.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org7a53e70}]{Power in terms of Monoid}
\begin{itemize}
\item In some cases all elements of the list are the same.
\pause
\begin{equation*}
  a + (a + (a + \ldots + a) \ldots ) = a ^ n
\end{equation*}
\end{itemize}

\pause

\begin{itemize}
\item Since we can reorder the parentheses, we can arrange them like this.
\end{itemize}

\pause
\begin{center}
\includegraphics[height=4cm]{.dot/fold-power-1.png}
\end{center}
\end{frame}

\begin{frame}[label={sec:org9d60c68}]{Power in terms of Monoid}
\begin{center}
\includegraphics[height=4cm]{.dot/fold-power-2.png}
\end{center}

Evaluating \(a + a\) always yields the same result. So there is no point in
repeating this calculation 4 times.
\end{frame}

\begin{frame}[label={sec:org72c2d7f}]{Power in terms of Monoid}
\begin{center}
\includegraphics[height=4cm]{.dot/fold-power-3.png}
\end{center}

The same thing with the upper level. In this particular example, we can avoid 4
operations out of 7. In general, this optimisation leads to the result in \(\log
n\) operations.
\end{frame}

\begin{frame}[label={sec:org738e38a},fragile]{Power in terms of Monoid}
 All this means that we can define a function \texttt{exp}:

\begin{minted}[]{scala}
def exp[A: Monoid](a: A, n: Int): A = {
  ???
}
\end{minted}
\end{frame}

\begin{frame}[label={sec:org7a4d714}]{Back to Fibonacci}
Fibonacci number can be defined in a different way.

\begin{equation*}
  \begin{pmatrix}
    F_{n+1} & F_n \\
    F_n & F_{n-1}
  \end{pmatrix} =
  \begin{pmatrix}
    1 & 1 \\
    1 & 0
  \end{pmatrix} ^ n
\end{equation*}

\pause

\begin{equation*}
  \begin{pmatrix}
    F_4 & F_3 \\
    F_3 & F_2
  \end{pmatrix} =
  \begin{pmatrix}
    1 & 1 \\
    1 & 0
  \end{pmatrix} ^ 3 =
  \begin{pmatrix}
    2 & 1 \\
    1 & 1
  \end{pmatrix} \cdot
  \begin{pmatrix}
    1 & 1 \\
    1 & 0
  \end{pmatrix} =
  \begin{pmatrix}
    3 & 2 \\
    2 & 1
  \end{pmatrix}
\end{equation*}
\end{frame}

\begin{frame}[label={sec:orge30a78a}]{Back to Fibonacci}
\begin{equation*}
  \begin{pmatrix}
    F_{n+1} & F_n \\
    F_n & F_{n-1}
  \end{pmatrix} =
  \begin{pmatrix}
    1 & 1 \\
    1 & 0
  \end{pmatrix} ^ n
\end{equation*}

\pause

\begin{itemize}
\item The Fibonacci number can be calculated using square nonnegative matrix
multiplication.
\item Square nonnegative matrices form Monoid with multiplication.
\item So we can put parentheses in a way we like it.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org96661f0},fragile]{Coding time}
 \begin{itemize}
\item Open \texttt{wax.exercise.fibonacci.Main} object.
\begin{itemize}
\item \texttt{Main} runs two implementations and profiles them.
\item \texttt{Fib} contains implementation of tailrec and matrix approaches.
\item \texttt{ExpUtils} implements generic \texttt{exp} function.
\end{itemize}
\item Task is to implement monoid for \texttt{Matrix2x2} in the \texttt{Fib} object.
\item Run \texttt{MatrixSpec} to test your instance.
\item Run \texttt{FibSpec} to test implementation of \texttt{Fib}.
\item Run \texttt{Main} to see performance differences by yourself.
\end{itemize}

\pause

\begin{columns}
\begin{column}[t]{0.5\columnwidth}
\vspace*{0px}

\begin{equation*}
  \begin{pmatrix}
    a_{11} & a_{12} \\
    a_{21} & a_{22}
  \end{pmatrix} \cdot
  \begin{pmatrix}
    b_{11} & b_{12} \\
    b_{21} & b_{22}
  \end{pmatrix} = \\
  \begin{pmatrix}
    a_{11} \cdot b_{11} + a_{12} \cdot b_{21} & a_{11} \cdot b_{12} + a_{12} \cdot b_{22} \\
    a_{21} \cdot b_{11} + a_{22} \cdot b_{21} & a_{21} \cdot b_{12} + a_{22} \cdot b_{22}
  \end{pmatrix}
\end{equation*}
\end{column}

\begin{column}[t]{0.5\columnwidth}
\begin{center}
\includegraphics[height=3cm]{images/matrix-mult.png}
\end{center}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:org631063e}]{Profiling results}
\begin{center}
\begin{tabular}{rrr}
N & Matrix & Tailrec\\
\hline
10 & 60 & 0\\
100 & 0 & 0\\
1000 & 1 & 1\\
10000 & 5 & 6\\
100000 & 46 & 168\\
1000000 & 888 & 15211\\
10000000 & 11266 & -\\
\end{tabular}
\end{center}
\end{frame}

\begin{frame}[label={sec:org6b60bb9},fragile]{Outcome}
 Just think about it.

\pause
Giving any monoid we have a helper function that efficiently calculates \(a^n\).

\pause
This is only possible because of the \alert{laws} that come with operations.

\pause
\texttt{combine} by itself is not interesting, it's too generic.

\pause
Laws give us \alert{properties}. Which we use to get a solution that works for
everything that is \texttt{Monoid}.

\pause
Monoids are everywhere around us. We deal with them every day, without even
noticing it. Did you expect us to solve Fibonacci using \texttt{Monoid}?

\pause
You might forget how matrix multiplication works, but now you remember, right?
\end{frame}

\section*{Books}
\label{sec:org8b27d41}

\begin{frame}[label={sec:org1f2fd08}]{Folds with Monoids}
\begin{itemize}
\item We already know that Monoids give us an ability to place parentheses in any
fashion.
\item We already saw that when it comes to folding the list of the same elements we
gain performance.
\item But what if the elements are not equal? Do we gain anything?
\end{itemize}

\pause
\begin{center}
\includegraphics[height=4cm]{.dot/fold-parallel-1.png}
\end{center}
\end{frame}

\begin{frame}[label={sec:org6148b60}]{Folds with Monoids}
\begin{center}
\includegraphics[height=4cm]{.dot/fold-parallel-2.png}
\end{center}

Every expression on each level does not depend on other expressions from the
same level, which means that we can evaluate them in parallel.
\end{frame}

\begin{frame}[label={sec:org764eb98},fragile]{MapReduce}
 \begin{itemize}
\item Sometimes we have a collection of elements that don't form Monoid.
\end{itemize}
\pause
\begin{itemize}
\item But we can transform (e.g. \texttt{map}) them into something that is a Monoid
\end{itemize}
\pause
\begin{itemize}
\item There is a strange accent, where people pronounce 'fold' as 'reduce'.
\end{itemize}
\pause
\begin{itemize}
\item This is how we get the \texttt{mapReduce}.
\end{itemize}
\pause
\begin{itemize}
\item Just think about it, \texttt{mapReduce} is possible thanks to \texttt{Monoid} and its
\emph{laws}.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org140b2b5},fragile]{Coding time}
 \begin{itemize}
\item <1-> Our goal is to find 10 top used words among multiple books.
\item <2-> Open \texttt{wax.exercise.mapreduce.MapReduce} file.
\item <3-> \texttt{MapReduce} object implements \texttt{mapReduce} function (two variants - par and
seq).
\item <4-> \texttt{Main} object runs (not yet defined) \texttt{job} and profiles it (par vs seq).
\item <5-> \texttt{Result[Int]} is a map with words and their usage counter.
\item <6-> Your goal is to:
\begin{enumerate}
\item Implement monoid instance for \texttt{MapReduce.Result[A]}.
\item Implement the \texttt{job} function to find the most used word.
\end{enumerate}
\item <7-> Use helpers from \texttt{FileUtils}:
\begin{itemize}
\item \texttt{readTokens} to get the list of words from the file.
\item \texttt{authorBooks} to get the list of books (files) by author (e.g.
\texttt{authorBooks("boris")}).
\item \texttt{allBooks} to get the list of all book among all available authors.
\end{itemize}
\end{itemize}
\end{frame}

\section*{Logger}
\label{sec:orgde56114}

\begin{frame}[label={sec:org0c1681a},fragile]{Things to note}
 \begin{itemize}
\item Functional programming is not about \texttt{Monads} and \texttt{IO}.
\begin{itemize}
\item Funny enough, first versions of Haskell were naked and no one dared to tell
the committee that \texttt{IO} is missing.
\end{itemize}
\item Functions matter.
\end{itemize}

\pause

\begin{itemize}
\item Can a function be monoid?
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org3131c57},fragile]{Let's start with some wrappers (pun intended)}
 \begin{itemize}
\item Suppose that we have some case class \texttt{Wrapper[A](value: A)}
\item Can it be a monoid?
\item Well, generally speaking, not! Because we know nothing about the type \texttt{A}.
\item But what if \texttt{A} is a monoid?
\end{itemize}

\pause

\begin{minted}[]{scala}
case class Wrapper[A](value: A)

object Wrapper {
  implicit def wrapperMonoid[A: Monoid]: Monoid[Wrapper[A]] = new Monoid[Wrapper[A]] {
    override def empty: Wrapper[A] = Wrapper(Monoid[A].empty)

    override def combine(x: Wrapper[A], y: Wrapper[A]): Wrapper[A] =
      Wrapper(Monoid[A].combine(x.value, y.value))
  }
}
\end{minted}
\end{frame}

\begin{frame}[label={sec:org21fbbcc},fragile]{Wrappers of monoids are monoids}
 \begin{itemize}
\item So IO can also be a monoid
\begin{minted}[]{scala}
def ioMonoid[A: Monoid]: Monoid[IO[A]] = ???
\end{minted}
\item Which means that we can combine IO actions (in some new sense).
\item Functions are wrappers (in some sense), so they also can be monoids
\begin{minted}[]{scala}
def functionMonoid[A, B: Monoid]: Monoid[Function[A, B]] = ???
\end{minted}
\item Which means that we can combine functions (in some new sense).
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org37b65a1},fragile]{Logger}
 \begin{itemize}
\item \texttt{Logger} is basically a function from \texttt{String} to \texttt{IO[Unit]}.
\begin{minted}[]{scala}
type Logger = String => IO[Unit]
\end{minted}
\item \texttt{Unit} forms a monoid.
\item So \texttt{IO[Unit]} forms a monoid.
\item So \texttt{String => IO[Unit]} forms a monoid.
\item So \texttt{Logger} forms a monoid.
\item So we can combine loggers
\begin{itemize}
\item \texttt{combine(fileLogger, consoleLogger)} - logs both into file and to console
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgfa6fa2a},fragile]{Logger}
 \begin{itemize}
\item Open \texttt{wax.exercise.logging} module
\item Task is to implement monoid for \texttt{IO[Logger]}
\item Have fun!
\end{itemize}
\end{frame}

\section*{Recap}
\label{sec:orgde42e1e}

\begin{frame}[label={sec:org30175ab},fragile]{Recap (recup?)}
 \begin{itemize}
\item Semigroup is something with means of combining these somethings.
\item Monoid is semigroup that also has neutral element that doesn't affect a combination.
\item Associativity is a powerful property giving us an ability to solve some tasks.
\begin{itemize}
\item \(a^n\) in \(\log n\)
\item \texttt{mapReduce}
\end{itemize}
\item Monoids are everywhere. They act like a plague, once something forms a monoid,
something else also begins to form a monoid.
\item We want some rest after a long session of forkshop.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org9da33cb}]{Questions?}
\centerline{\huge $\epsilon \rho \omega \tau \eta \sigma \eta$?}
\end{frame}

\begin{frame}[label={sec:org3f7f0e9}]{Thank you very much!}
\centerline{\huge We hope you enjoyed this session.}
\end{frame}
\end{document}
